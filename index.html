<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Engineering Calculator</title>
    <!--
        This project uses math.js, which is licensed under the Apache License, Version 2.0 (the "License").
        You may not use this file except in compliance with the License.
        You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0
        Unless required by applicable law or agreed to in writing, software distributed under the License
        is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        See the License for the specific language governing permissions and limitations under the License.
    -->
    <script src="math.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 10px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .container {
            flex: 1;
            display: flex;
            min-height: 0;
        }
        .editor-container, .output-container {
            flex: 1;
            padding: 10px;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        .editor-container {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .output-container {
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        #calculator-input {
            flex: 1;
            width: 100%;
            box-sizing: border-box;
            margin: 10px 0;
            overflow-y: auto;
            resize: none;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 0;
        }
        button:hover {
            background: #45a049;
        }
        .footer {
            padding: 20px;
            border-top: 1px solid #ddd;
            font-size: 14px;
            color: #666;
            text-align: center;
            margin-top: 10px;
        }
        .footer a {
            color: #4CAF50;
            text-decoration: none;
            font-weight: bold;
        }
        .footer a:hover {
            text-decoration: underline;
        }
        .footer .dark-link {
            color:#333;
        }
        .dark-mode .footer .dark-link {
            color:#d8d8d8;
        }
        #resizer {
            width: 8px;
            background: #ddd;
            cursor: col-resize;
            flex: 0 0 auto;
            transition: background 0.3s;
        }

        #resizer:hover {
            background: #999;
        }

        .dark-mode #resizer {
            background: #404040;
        }

        .dark-mode #resizer:hover {
            background: #666;
        }

        #output div.error {
            color: #d32f2f;
            font-family: monospace;
        }
        #output {
            flex: 1;
            overflow-y: auto;
            margin: 10px 0;
            font-size: 0.9em;
            
        }
        .katex {
            font-size: 1.1em !important;
            padding-left: 0px !important;
        }
        .katex-display {
            margin-left: 0px !important;
            margin-bottom: 0px !important;
            margin-top: 0px !important;
        }
        .editor-container h3 {
            display: inline-block;
            margin-right: 10px;
        }
        .editor-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            justify-content: space-between;
        }
        .editor-header h3 {
            margin: 0;
            margin-right: 10px;
        }

        /* Add dark mode styles */
        body.dark-mode {
            background-color: #1e1e1e;
            color: #e0e0e0;
        }

        .dark-mode .editor-container {
            background: #2d2d2d;
            border-color: #404040;
        }

        .dark-mode .output-container {
            background: #1e1e1e;
            border-color: #404040;
            color: #e0e0e0;
        }

        .dark-mode #calculator-input {
            background: #2d2d2d;
            color: #e0e0e0;
            border: 1px solid #404040;
        }

        .dark-mode .footer {
            border-color: #404040;
            color: #888;
        }

        .dark-mode button {
            background: #2e7d32;
        }

        .dark-mode button:hover {
            background: #1b5e20;
        }

        /* Update theme-toggle styles */
        .theme-toggle {
            position: absolute; 
            bottom: 20px;    /* Change from top to bottom */
            right: 20px;
            padding: 8px 12px;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }

        .dark-mode .theme-toggle {
            background: #2e7d32;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="editor-container">
            <div class="editor-header">
                <h3>Input</h3>
                <div> Shift-Enter or <button onclick="evaluateCalculator()">Evaluate</button> </div>
            </div>
            <textarea id="calculator-input" spellcheck="false" onkeydown="handleKeyPress(event)"></textarea>
        </div>
        <div id="resizer" onmousedown="startDrag(event)"></div>
        <div class="output-container">
            <h3>Results</h3>
            <div id="output"></div>
        </div>
    </div>
    <div class="footer">
        Created by <a class = "dark-link", href="https://www.linkedin.com/in/shiv-raja-b378a5216/" target="_blank">Shiv Raja</a> &nbsp; | &nbsp; 
        Copyright Â© 2024 Shiv Raja &nbsp; | &nbsp;
        Powered by <a href="https://mathjs.org" target="_blank">mathjs.org</a> &nbsp; | &nbsp;
        Licensed under <a href="https://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache 2.0</a>&nbsp;| &nbsp;
        <br>
        <a class = "dark-link", href="https://github.com/sr23k/engineering_calculator" target="_blank">github.com/sr23k/engineering_calculator</a>
        v0.0 &nbsp; | &nbsp;  <a href="engineering_calculator_v0p0.html" download>Download for offline use</a>  &nbsp; | &nbsp; WIP: double-check outputs
        <button class="theme-toggle" onclick="toggleTheme()">Toggle Theme</button>
    </div>
    
    <script>
    let startX, startWidthPercent;
    const minWidthPercent = 20;
    const maxWidthPercent = 80;

    function startDrag(e) {
        e.preventDefault();  // Prevent text selection while dragging
        startX = e.clientX;
        const editorContainer = document.querySelector('.editor-container');
        const containerWidth = document.querySelector('.container').offsetWidth;
        startWidthPercent = (editorContainer.offsetWidth / containerWidth) * 100;
        
        document.addEventListener('mousemove', doDrag);
        document.addEventListener('mouseup', stopDrag);
    }

    function doDrag(e) {
        const container = document.querySelector('.container');
        const editorContainer = document.querySelector('.editor-container');
        const outputContainer = document.querySelector('.output-container');
        
        const containerWidth = container.offsetWidth;
        const deltaX = e.clientX - startX;
        const deltaPercent = (deltaX / containerWidth) * 100;
        let newWidthPercent = Math.min(maxWidthPercent, Math.max(minWidthPercent, startWidthPercent + deltaPercent));
        
        editorContainer.style.flex = `0 0 ${newWidthPercent}%`;
        outputContainer.style.flex = `0 0 ${100 - newWidthPercent - 2}%`;  // Subtract resizer width percentage
    }

    function stopDrag() {
        document.removeEventListener('mousemove', doDrag);
        document.removeEventListener('mouseup', stopDrag);
    }

    // Initialize containers with percentage-based widths
    document.addEventListener('DOMContentLoaded', () => {
        const defaultWidthPercent = 49; // Slightly less than 50 to account for resizer
        const editorContainer = document.querySelector('.editor-container');
        const outputContainer = document.querySelector('.output-container');
        
        editorContainer.style.flex = `0 0 ${defaultWidthPercent}%`;
        outputContainer.style.flex = `0 0 ${100 - defaultWidthPercent - 2}%`;  // Subtract resizer width percentage
    });
    </script>

    <script src="dimension.js"></script>   
    <script>
        // Create parser with all units available
        const parser = math.parser();
        const equations = {};

        // Add engineering constants (extending math.js built-in constants)
        const engineeringConstants = {
            // Standard gravity
            g: math.unit('9.80665 m/s^2'),
            // Gas constant
            R: math.unit('8.31446261815324 J/(mol*K)'),
            // Boltzmann constant
            k: math.unit('1.380649e-23 J/K'),
            // Stefan-Boltzmann constant
            sigma: math.unit('5.670374419e-8 W/(m^2*K^4)'),
            // Planck constant
            h: math.unit('6.62607015e-34 J*s'),
            // Speed of light
            c: math.unit('299792458 m/s'),
            // Electron mass
            me: math.unit('9.1093837015e-31 kg'),
            // Proton mass
            mp: math.unit('1.67262192369e-27 kg'),
            // Atmospheric pressure
            atm: math.unit('101325 Pa'),
            // Water properties at standard conditions
            rho_water: math.unit('998 kg/m^3'),
            cp_water: math.unit('4186 J/(kg*K)'),
            // Air properties at standard conditions
            rho_air: math.unit('1.225 kg/m^3'),
            cp_air: math.unit('1005 J/(kg*K)')
        };

        // Add constants to parser
        Object.entries(engineeringConstants).forEach(([name, value]) => {
            parser.set(name, value);
        });

        function findFreeVariable(equation){
            console.log(math.parse(equation));
            return 1;
        }

        // Function to detect unit from an equation
        function detectUnit(equation, variable) {
            try {
                const sides = equation.split('==');
                if (sides.length !== 2) return null;
                
                // Store current value if exists

                const oldMap = parser.getAllAsMap();
                newMap = new Map();
                for (const [key, value] of oldMap) {
                    if(math.typeOf(value) == "Unit"){
                        newMap.set(key, new Dimension(value.dimensions));
                    } else {
                        newMap.set(key, new Dimension([0, 0, 0, 0, 0, 0, 0, 0, 0]));
                    }
                }

                // Try with a simple unit value
                newMap.set(variable, new Dimension([0, 0, 0, 0, 0, 0, 0, 0, 0], variable));
                const left = math.evaluate(sides[0].trim(), newMap);
                const right = math.evaluate(sides[1].trim(), newMap);

                const finalExpression = math.subtract(left, right).var_vals;
                const finalDimension = finalExpression.get(variable)[0];
                const finalPower = finalExpression.get(variable)[1];
                let unit = [`gram^${finalDimension[0]/finalPower}`,
                            `meter^${finalDimension[1]/finalPower}`,
                            `second^${finalDimension[2]/finalPower}`,
                            `ampere^${finalDimension[3]/finalPower}`,
                            `kelvin^${finalDimension[4]/finalPower}`,
                            `candela^${finalDimension[5]/finalPower}`,
                            `mole^${finalDimension[6]/finalPower}`,
                            `deg^${finalDimension[7]/finalPower}`,
                            `bits^${finalDimension[8]/finalPower}`
                        ];
                return unit.join(' ') || null;
            } catch (error) {
                throw new Error('Error in variable detection: ' + error.message);
            }
            return null;
        }

        function splitValueAndUnit(valueWithUnit) {
            const [value, ...unit] = valueWithUnit.toString().split(' ');
            return {
                value: parseFloat(value),
                unit: unit.join(' ') || null
            };
        }

        // Add solve function with improved unit handling
        function solveEquation(equationName, variable, initialValue = "1.0") {
            if (!(equationName in equations)) {
                throw new Error(`Equation ${equationName} not found`);
            }
            const equation = equations[equationName];
            const sides = equation.split('==');
            if (sides.length !== 2) {
                throw new Error('Invalid equation format. Use == for equations.');
            }

            // Get or detect unit
            let unit;
            try {
                const currentValue = parser.get(variable);
                unit = splitValueAndUnit(currentValue).unit;
            } catch (error) {
                unit = detectUnit(equation, variable);
            }

            if (!unit) {
                throw new Error('Could not determine units for variable ' + variable);
            }

            const leftSide = sides[0].trim();
            const rightSide = sides[1].trim();

            // Create function that returns the difference between sides
            function evaluateEquation(x) {
                try{
                    parser.set(variable, math.unit(x, unit));
                    const left = parser.evaluate(leftSide);
                    const right = parser.evaluate(rightSide);
                    // Check if both sides have units, then convert them to scalars for comparison
                    if (left.units && right.units) {
                        return math.subtract(left, right).toNumber();
                    } else {
                        throw new Error('Units do not match in equation');
                    }
                } catch (error){
                    throw new Error("Failed to evaluate expression: " + error.message);
                }
            }


            // Newton-Raphson method with unit handling
            function newtonRaphson(f, x0, tolerance = 1e-10, maxIterations = 100) {
                let x = x0;
                for (let i = 0; i < maxIterations; i++) {
                    const fx = f(x);
                    if (Math.abs(fx) < tolerance) {
                        return x;
                    }

                    // Numerical derivative with appropriate scaling
                    const h = Math.max(1e-10, Math.abs(x) * 1e-6);
                    const df = (f(x + h) - fx) / h;
                    
                    if (df === 0) {
                        throw new Error('Derivative is zero. Cannot continue.');
                    }
                    
                    const delta = fx / df;
                    x = x - delta;
                }
                throw new Error('Failed to converge');
            }
            initialValue = math.evaluate(initialValue);
            try {
                const current = parser.get(variable);
                if (current && current.units) {
                    initialValue = current.toNumber();
                }
            } catch (error) {
                // Use default initial value
            }

            try {
                const solution = newtonRaphson(evaluateEquation, initialValue);
                return math.unit(solution, unit);
            } catch(error){
                throw new Error(`Failed to solve equation: ${error.message}`);
            }
        }

        // Add this new function before evaluateCalculator()
        function handleKeyPress(event) {
            if (event.key === 'Enter' && (event.ctrlKey || event.shiftKey)) {
                event.preventDefault();  // Prevent default newline
                evaluateCalculator();
            }
        }

        // Function to evaluate input
        function evaluateCalculator() {
            const input = document.getElementById('calculator-input').value;
            const output = document.getElementById('output');
            const lines = input.split('\n');
            let results = [];

            const eqnAssign = /^[^=]*=[^=]*==[^=]*$/;
            const standAloneEqn = /^[^\=]*==[^=]*$/;
            output.innerHTML = '';

            // Reset parser (but keep constants) and equations
            parser.clear();
            Object.entries(engineeringConstants).forEach(([name, value]) => {
                parser.set(name, value);
            });
            Object.keys(equations).forEach(key => delete equations[key]);
            
            try {
                for (let line of lines) {
                    line = line.trim();
                    if(!line){
                        const commentDiv = document.createElement('br');
                        output.appendChild(commentDiv);
                        continue;
                    }
                    if (line.startsWith('//')) {
                        // Create a text node for comments
                        const commentDiv = document.createElement('div');
                        commentDiv.textContent = line;
                        output.appendChild(commentDiv);
                        continue;
                    }

                    try {
                        let resultText;
                        if (line.includes('solve(')) {
                            // Handle solve function...
                            const match = line.match(/solve\(([^)]+)\)/)[1].split(/\s*,\s*/);
                            if (match) {
                                const equationName = match[0].trim();
                                const variable = match[1].trim();
                                let solution;
                                if(match.length > 2){
                                    const initialValue = match[2].trim();
                                    solution = solveEquation(equationName, variable, initialValue);
                                    resultText = `\\mathrm{solve}\\left(\\mathrm{${equationName}}, \\mathrm{${variable}}, ${initialValue}\\right) = ${math.parse(solution.toString()).toTex()}`;
                                } else {
                                    solution = solveEquation(equationName, variable);
                                    resultText = `\\mathrm{solve}\\left(\\mathrm{${equationName}}, \\mathrm{${variable}}\\right) = ${math.parse(solution.toString()).toTex()}`;
                                }
                                parser.set(variable, solution);
                            }
                        } else if (eqnAssign.test(line)) {
                            // Store equation for later use
                            const parts = line.split('=');
                            const name = parts[0].trim();
                            const equation = line.substring(line.indexOf('=') + 1).trim().split('//')[0].trim();
                            equations[name] = equation;
                            console.log(math.parse(equation).toTex());
                            resultText = `\\mathrm{${name}} := ${math.parse(equation).toTex()}`;
                        } else if (standAloneEqn.test(line)){
                            variable = findFreeVariable(line);
                            const equationName = "dummy";
                            solution = solveEquation(equationName, variable);
                            resultText = `\\mathrm{${line}} = ${math.parse(solution.toString()).toTex()}`;
                            parser.set(variable, solution);
                        } else if (line.includes('=')) {
                            // Handle assignment
                            const parts = line.split('=');
                            const name = parts[0].trim();
                            const expr = parts[1].split('//')[0].trim(); // Remove comments
                            const result = parser.evaluate(expr);
                            parser.set(name, result);
                            resultText = `${name} := ${math.parse(expr.toString()).toTex()} \\to ${math.parse(result.toString()).toTex()}`;
                        } else if(line.includes('to')){
                            // Handle unit conversion
                            const parts = line.split('to');
                            const value = parts[0].trim();
                            const unit = parts[1].trim();
                            const result = parser.evaluate(line);
                            resultText = `\\text{${value}} \\to \\mathrm{${unit}} = ${math.parse(result.toString()).toTex()}`;
                        } else{
                            // Direct evaluation
                            const result = parser.evaluate(line);
                            resultText = `\\text{${line}} := ${math.parse(result.toString()).toTex()}`;
                        }

                        // Create a new div for each result and render with KaTeX
                        const resultDiv = document.createElement('div');
                        katex.render(resultText, resultDiv, {
                            displayMode: true,
                            throwOnError: false,
                            fleqn: true,
                        });
                        output.appendChild(resultDiv);

                    } catch (error) {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'error';
                        errorDiv.textContent = `Error in line "${line}": ${error.message}`;
                        output.appendChild(errorDiv);
                    }
                }
            } catch (error) {
                output.innerHTML = `Error: ${error.message}`;
            }
        }
        document.getElementById('calculator-input').value = `// Function reference: https://mathjs.org/docs/reference/functions.html
// Example using constants and unit solving
T = 300 K
P = 2 atm

// Solve for required volume to get 2 moles
eqn1 = P * V / (R * T) == 2 mol

// Root-finding solver, initial guess = 1
solve(eqn1, V)

// Or specify initial guess
solve(eqn1, V, 0.1)

// Unit Conversions
V to in^3

// Example with speed calculation
v_i = 10 m/s
t = 2 s
d = 100 m

// Find acceleration needed to cover distance
a = 5 m/s^2  // initial guess can be directly specified
eqn2 = v_i * t + 0.5 * a * t^2 == d
solve(eqn2, a)`;
    </script>

    <script>
        // Add this before your existing scripts
        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            // Optionally save preference
            const isDarkMode = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDarkMode);
        }

        // Load saved theme preference
        document.addEventListener('DOMContentLoaded', () => {
            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            if (isDarkMode) {
                document.body.classList.add('dark-mode');
            }
        });
    </script>
</body>
</html>