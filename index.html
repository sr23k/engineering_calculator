<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Engineering Calculator</title>
    <!--
        This project uses math.js, which is licensed under the Apache License, Version 2.0 (the "License").
        You may not use this file except in compliance with the License.
        You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0
        Unless required by applicable law or agreed to in writing, software distributed under the License
        is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        See the License for the specific language governing permissions and limitations under the License.
    -->
    <script src="math.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            max-width: 100%;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            display: flex;
            height: calc(100vh - 100px);
        }
        .editor-container, .output-container {
            flex: 1;
            padding: 10px;
            overflow: auto;
        }
        .editor-container {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 5px;
        }
        .output-container {
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-left: 5px;
        }
        #calculator-input {
            width: 100%;
            height: calc(100% - 50px);
            font-family: monospace;
            font-size: 14px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            resize: none;
        }
        #output {
            height: calc(100% - 40px);
            white-space: pre-wrap;
            font-family: monospace;
            overflow: auto;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background: #45a049;
        }
        .footer {
            margin-top: 20px;
            padding: 15px;
            border-top: 1px solid #ddd;
            font-size: 14px;
            color: #666;
            text-align: center;
        }
        .footer a {
            color: #4CAF50;
            text-decoration: none;
            font-weight: bold;
        }
        .footer a:hover {
            text-decoration: underline;
        }
        #resizer {
            width: 10px;
            background: #ddd;
            cursor: col-resize;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="editor-container">
            <h3>Input</h3>
            <textarea id="calculator-input" spellcheck="false" onkeydown="handleKeyPress(event)"></textarea>
            <button onclick="evaluateCalculator()">Evaluate</button>
        </div>
        <div id="resizer" onmousedown="startDrag(event)"></div>
        <div class="output-container">
            <h3>Results</h3>
            <div id="output"></div>
        </div>
    </div>
    <div class="footer">
        Created by <a style = "color: #333;", href="https://www.linkedin.com/in/shiv-raja-b378a5216/" target="_blank">Shiv Raja</a> &nbsp; | &nbsp; 
        Copyright Â© 2024 Shiv Raja &nbsp; | &nbsp;
        Powered by <a href="https://mathjs.org" target="_blank">mathjs.org</a> &nbsp; | &nbsp;
        Licensed under <a href="https://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache 2.0</a>&nbsp;| &nbsp;
        <br>
        <a style = "color: #333;" href="https://github.com/sr23k/engineering_calculator" target="_blank">github.com/sr23k/engineering_calculator</a>
        v0.0 &nbsp; | &nbsp;  <a href="engineering_calculator_v0p0.html" download>Download for offline use</a>  &nbsp; | &nbsp; WIP: double-check outputs
    </div>
    
    <script>
    let startX, startWidth, startOutputWidth;
        function startDrag(e) {
            startX = e.clientX;
            startWidth = parseInt(window.getComputedStyle(document.querySelector('.editor-container')).width, 10);
            startOutputWidth = parseInt(window.getComputedStyle(document.querySelector('.output-container')).width, 10);
            document.documentElement.addEventListener('mousemove', doDrag, false);
            document.documentElement.addEventListener('mouseup', stopDrag, false);
        }
        function doDrag(e) {
            const newWidth = startWidth + e.clientX - startX;
            const newOutputWidth = startOutputWidth - (e.clientX - startX);
            document.querySelector('.editor-container').style.flex = '0 0 ' + newWidth + 'px';
            document.querySelector('.output-container').style.flex = '0 0 ' + newOutputWidth + 'px';
        }
        function stopDrag() {
            document.documentElement.removeEventListener('mousemove', doDrag, false);
            document.documentElement.removeEventListener('mouseup', stopDrag, false);
        }
    </script>

    <script src="dimension.js"></script>   
    <script>
        // Create parser with all units available
        const parser = math.parser();
        const equations = {};

        // Add engineering constants (extending math.js built-in constants)
        const engineeringConstants = {
            // Standard gravity
            g: math.unit('9.80665 m/s^2'),
            // Gas constant
            R: math.unit('8.31446261815324 J/(mol*K)'),
            // Boltzmann constant
            k: math.unit('1.380649e-23 J/K'),
            // Stefan-Boltzmann constant
            sigma: math.unit('5.670374419e-8 W/(m^2*K^4)'),
            // Planck constant
            h: math.unit('6.62607015e-34 J*s'),
            // Speed of light
            c: math.unit('299792458 m/s'),
            // Electron mass
            me: math.unit('9.1093837015e-31 kg'),
            // Proton mass
            mp: math.unit('1.67262192369e-27 kg'),
            // Atmospheric pressure
            atm: math.unit('101325 Pa'),
            // Water properties at standard conditions
            rho_water: math.unit('998 kg/m^3'),
            cp_water: math.unit('4186 J/(kg*K)'),
            // Air properties at standard conditions
            rho_air: math.unit('1.225 kg/m^3'),
            cp_air: math.unit('1005 J/(kg*K)')
        };

        // Add constants to parser
        Object.entries(engineeringConstants).forEach(([name, value]) => {
            parser.set(name, value);
        });

        function findFreeVariable(equation){
            console.log(math.parse(equation));
            return 1;
        }

        // Function to detect unit from an equation
        function detectUnit(equation, variable) {
            try {
                const sides = equation.split('==');
                if (sides.length !== 2) return null;
                
                // Store current value if exists

                const oldMap = parser.getAllAsMap();
                newMap = new Map();
                for (const [key, value] of oldMap) {
                    if(math.typeOf(value) == "Unit"){
                        newMap.set(key, new Dimension(value.dimensions));
                    } else {
                        newMap.set(key, new Dimension([0, 0, 0, 0, 0, 0, 0, 0, 0]));
                    }
                }

                // Try with a simple unit value
                newMap.set(variable, new Dimension([0, 0, 0, 0, 0, 0, 0, 0, 0], variable));
                const left = math.evaluate(sides[0].trim(), newMap);
                const right = math.evaluate(sides[1].trim(), newMap);

                const finalExpression = math.subtract(left, right).var_vals;
                const finalDimension = finalExpression.get(variable)[0];
                const finalPower = finalExpression.get(variable)[1];
                let unit = [`gram^${finalDimension[0]/finalPower}`,
                            `meter^${finalDimension[1]/finalPower}`,
                            `second^${finalDimension[2]/finalPower}`,
                            `ampere^${finalDimension[3]/finalPower}`,
                            `kelvin^${finalDimension[4]/finalPower}`,
                            `candela^${finalDimension[5]/finalPower}`,
                            `mole^${finalDimension[6]/finalPower}`,
                            `deg^${finalDimension[7]/finalPower}`,
                            `bits^${finalDimension[8]/finalPower}`
                        ];
                return unit.join(' ') || null;
            } catch (error) {
                throw new Error('Error in variable detection: ' + error.message);
            }
            return null;
        }

        function splitValueAndUnit(valueWithUnit) {
            const [value, ...unit] = valueWithUnit.toString().split(' ');
            return {
                value: parseFloat(value),
                unit: unit.join(' ') || null
            };
        }

        // Add solve function with improved unit handling
        function solveEquation(equationName, variable, initialValue = "1.0") {
            if (!(equationName in equations)) {
                throw new Error(`Equation ${equationName} not found`);
            }
            const equation = equations[equationName];
            const sides = equation.split('==');
            if (sides.length !== 2) {
                throw new Error('Invalid equation format. Use == for equations.');
            }

            // Get or detect unit
            let unit;
            try {
                const currentValue = parser.get(variable);
                unit = splitValueAndUnit(currentValue).unit;
            } catch (error) {
                unit = detectUnit(equation, variable);
            }

            if (!unit) {
                throw new Error('Could not determine units for variable ' + variable);
            }

            const leftSide = sides[0].trim();
            const rightSide = sides[1].trim();

            // Create function that returns the difference between sides
            function evaluateEquation(x) {
                try{
                    parser.set(variable, math.unit(x, unit));
                    const left = parser.evaluate(leftSide);
                    const right = parser.evaluate(rightSide);
                    // Check if both sides have units, then convert them to scalars for comparison
                    if (left.units && right.units) {
                        return math.subtract(left, right).toNumber();
                    } else {
                        throw new Error('Units do not match in equation');
                    }
                } catch (error){
                    throw new Error("Failed to evaluate expression: " + error.message);
                }
            }


            // Newton-Raphson method with unit handling
            function newtonRaphson(f, x0, tolerance = 1e-10, maxIterations = 100) {
                let x = x0;
                for (let i = 0; i < maxIterations; i++) {
                    const fx = f(x);
                    if (Math.abs(fx) < tolerance) {
                        return x;
                    }

                    // Numerical derivative with appropriate scaling
                    const h = Math.max(1e-10, Math.abs(x) * 1e-6);
                    const df = (f(x + h) - fx) / h;
                    
                    if (df === 0) {
                        throw new Error('Derivative is zero. Cannot continue.');
                    }
                    
                    const delta = fx / df;
                    x = x - delta;
                }
                throw new Error('Failed to converge');
            }
            initialValue = math.evaluate(initialValue);
            try {
                const current = parser.get(variable);
                if (current && current.units) {
                    initialValue = current.toNumber();
                }
            } catch (error) {
                // Use default initial value
            }

            try {
                const solution = newtonRaphson(evaluateEquation, initialValue);
                return math.unit(solution, unit);
            } catch(error){
                throw new Error(`Failed to solve equation: ${error.message}`);
            }
        }

        // Add this new function before evaluateCalculator()
        function handleKeyPress(event) {
            if (event.key === 'Enter' && (event.ctrlKey || event.shiftKey)) {
                event.preventDefault();  // Prevent default newline
                evaluateCalculator();
            }
        }

        // Function to evaluate input
        function evaluateCalculator() {
            const input = document.getElementById('calculator-input').value;
            const output = document.getElementById('output');
            const lines = input.split('\n');
            let results = [];

            const eqnAssign = /^[^=]*=[^=]*==[^=]*$/;
            const standAloneEqn = /^[^\=]*==[^=]*$/;

            // Reset parser (but keep constants) and equations
            parser.clear();
            Object.entries(engineeringConstants).forEach(([name, value]) => {
                parser.set(name, value);
            });
            Object.keys(equations).forEach(key => delete equations[key]);
            
            try {
                for (let line of lines) {
                    line = line.trim();
                    if (!line || line.startsWith('//')) {
                        results.push(line);
                        continue;
                    }

                    try {
                        if (line.includes('solve(')) {
                            // Parse solve function call
                            const match = line.match(/solve\(([^)]+)\)/)[1].split(/\s*,\s*/);
                            if (match) {
                                const equationName = match[0].trim();
                                const variable = match[1].trim();
                                let solution = null
                                if(match.length > 2){
                                    const initialValue = match[2].trim();
                                    solution = solveEquation(equationName, variable, initialValue);
                                } else {
                                    solution = solveEquation(equationName, variable);
                                }
                                results.push(`${line} = ${solution.toString()}`);
                                parser.set(variable, solution);
                            }
                        } else if (eqnAssign.test(line)) {
                            // Store equation for later use
                            const parts = line.split('=');
                            const name = parts[0].trim();
                            const equation = line.substring(line.indexOf('=') + 1).trim();
                            equations[name] = equation;
                            results.push(line);
                        } else if (standAloneEqn.test(line)){
                            variable = findFreeVariable(line);
                            const equationName = "dummy";
                            solution = solveEquation(equationName, variable);
                            results.push(`${line} = ${solution.toString()}`);
                            parser.set(variable, solution);
                        } else if (line.includes('=')) {
                            // Handle assignment
                            const parts = line.split('=');
                            const name = parts[0].trim();
                            const expr = parts[1].split('//')[0].trim(); // Remove comments
                            const result = parser.evaluate(expr);
                            parser.set(name, result);
                            results.push(`${name} = ${result.toString()}`);
                        } else {
                            // Direct evaluation
                            const result = parser.evaluate(line);
                            results.push(`${line} = ${result.toString()}`);
                        }
                    } catch (error) {
                        results.push(`Error in line "${line}": ${error.message}`);
                    }
                }
                output.textContent = results.join('\n');
            } catch (error) {
                output.textContent = `Error: ${error.message}`;
            }
        }
        document.getElementById('calculator-input').value = `// Function reference: https://mathjs.org/docs/reference/functions.html
// Example using constants and unit solving
T = 300 K
P = 2 atm

// Solve for required volume to get 2 moles
eqn1 = P * V / (R * T) == 2 mol

// Root-finding solver, initial guess = 1
solve(eqn1, V)

// Or specify initial guess
solve(eqn1, V, 0.1)

// Unit Conversions
V to in^3

// Example with speed calculation
v_initial = 10 m/s
t = 2 s
d = 100 m

// Find acceleration needed to cover distance
a = 5 m/s^2  // initial guess can be directly specified
eqn2 = v_initial * t + 0.5 * a * t^2 == d
solve(eqn2, a)`;
    </script>
</body>
</html>